\documentclass{article}

\usepackage{graphicx}
\usepackage{natbib}
\usepackage{listings}
\usepackage{polyglossia}
\setdefaultlanguage{italian}
\setotherlanguages{english}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\setlength\parindent{0pt}
\title{
    Analisi statica e dinamica di codice \texttt{C/C++} \\ con
    \texttt{Cppcheck} e \texttt{Valgrind} \\ \vspace{16px}
    \small Corso di Affidabilità e Sicurezza \\ dei Sistemi Software Complessi A.A. 2019/2020
}

\author{\textsc{Bernardo Giordano A18/254}}
\date{\today}

\begin{document}
\maketitle

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introduzione}

\subsection{Obiettivo}
\label{sec:obiettivo}

L'obiettivo dell'assignment è quello di approfondire le tecniche di analisi
statica e dinamica del codice \texttt{C}/\texttt{C++} per scoprire problemi relativi allo
scorretto utilizzo della memoria, come ad esempio mancata deallocazione (memory
leak), accesso a locazioni di memoria non valide e undefined behaviour.

In particolare, si approfondiranno i software open source \texttt{Cppcheck} e
\texttt{Valgrind} rispettivamente per l'analisi statica e quella dinamica.

\subsection{Analisi statica}
\label{sec:analisistatica}

L'analisi statica è un processo di valutazione di un sistema (in questo caso
software) o di un suo componente, volto all'analisi della sua forma, contenuto e
struttura senza che esso sia messo in esecuzione. Nella maggior parte dei casi,
l'analisi statica viene eseguita direttamente sul codice sorgente o sul codice
oggetto del programma.

L'analisi statica effettuata sul software varia a seconda del tool, in quanto
alcuni vanno a considerare solo il comportamento degli statement singoli e le
dichiarazioni di variabili all'interno di una porzione circoscritta di codice,
mentre altri vanno ad effettuare una analisi complessiva a partire dal codice
sorgente completo del programma. 

Le informazioni che si ricavano da un processo di analisi statica variano sono
molto variegate:

\begin{enumerate}
    \item highlighting di errori nel coding (sintattici o meno), come avviene
    per i tool di \emph{linting}
    \item segnalazione di variabili dichiarate e mai usate
    \item segnalazione di funzioni dichiarate e mai invocate
    \item segnalazione di memoria mai deallocata (\emph{memory leak})
    \item segnalazione di possibili loop infiniti dovuti all'irraggiungibilità
    di una o più condizioni di arresto
    \item \ldots
\end{enumerate}

L'analisi statica è una fase molto importante dello sviluppo del software (in
particolare in fase di validazione) e viene utilizzata spesso per sistemi
safety-critical e per scovare codice potenzialmente vulnerabile. Un corretto
utilizzo di questa tecnica previene l'occorrenza di errori all'interno del
software in fase di esecuzione e permette di rilasciare software in produzione
che non presenta guasti che spesso si vanno a scoprire solo con il codice in
esecuzione, quando magari è già tardi perché si sono già manifestati in fallimenti.

Tra le varie tecniche di analisi statica troviamo:

\begin{itemize}
    \item Analisi statica in compilazione: viene effettuata dal compilatore
    prima di generare il codice oggetto, per verificare caratteristiche di
    correttezza (sintattica, di coerenza tra tipi e parametri, codice non raggiungibile)
    \item Code reading: lettura individuale del codice per evidenziare
    errori/discrepanze con il progetto (tecniche basate su checklist o guidate
    dai casi d'uso)
    \item Code review: riunioni formali a cui partecipa un gruppo di persone che
    revisiona il codice allo stesso tempo
    \item Walkthrough: simulazione di casi di test eseguendo le istruzioni nel
    codice a mano
    \item Analisi del dataflow: studio del \emph{Control Flow Graph}
    \item Esecuzione simbolica: esecuzione del programma con valori simbolici
    dei dati di input invece che con valori effettivi
\end{itemize}

\subsection{Analisi dinamica}
\label{sec:analisidinamica}

L'analisi dinamica è un processo di analisi del software che prevede
l'esecuzione di un programma su un processore reale o virtuale. \\

Ci sono diverse tipologie di analisi dinamica:

\begin{itemize}
    \item Code coverage:
    \item Memory error detection:
    \item Fault localization:
    \item Concurrency errors:
    \item Performance analysis:
\end{itemize}

\subsection{Aging}
\label{sec:aging}
 
%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Cppcheck}

\subsection{Panoramica}
\label{sec:cppcheck:panoramica}

\subsection{Installazione}
\label{sec:cppcheck:installazione}

\subsection{Funzionalità}
\label{sec:cppcheck:funzionalita}

%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------

\section{Valgrind}

\subsection{Panoramica}
\label{sec:valgrind:panoramica}

Valgrind è un framework in grado di fornire una strumentazione ai binari dello spazio utente. \\

Valgrind rende disponibili un certo numero di strumenti per il profiling per il
miglioramento delle prestazioni e per una esecuzione corretta
delle applicazioni. Questi strumenti sono in grado di rilevare errori relativi
ai thread e alla memoria, permettendo
così una identificazione e correzione più semplice degli errori nel codice
dell'applicazione. Essi sono in grado di analizzare la cache, l'heap e la
previsione del branch, per identificare i fattori in grado di aumentare la
velocità dell'applicazione e ridurre l'uso della memoria. \\

Valgrind analizza l'applicazione eseguendola su una CPU sintetica, monitorandola
e misurando le prestazioni del codice esistente durante la sua esecuzione.
Successivamente stampa dei report identificando ogni processo presente
nell'esecuzione dell'applicazione su un descrittore del file specificato
dall'utente, un file, o una socket di rete. Il livello di arricchimento delle
funzioni eseguite varia in base
allo strumento di Valgrind usato e alle impostazioni, ed è importante notare
che l'esecuzione di un codice "instrumentato" può richiedere un tempo dai 4-50
volte più lungo rispetto al tempo di esecuzione normale. \\

Valgrind può essere usato sulle applicazioni senza alcuna ricompilazione
aggiuntiva. Tuttavia, poichè Valgrind utilizza informazioni di debugging per
definire le problematiche nel codice, se l'applicazione e le librerie di
supporto non sono state compilate con informazioni di debugging abilitate, è
generalmente consigliato ricompilare l'applicazione in modalità di debug.

\subsection{Installazione}
\label{sec:valgrind:installazione}

Il framework Valgrind può essere installato in maniera semplice da un repository
che lo contiene, oppure installandolo direttamente da pacchetto. Ad esempio, su
una distribuzione Debian/Ubuntu: \\

\begin{lstlisting}[language=bash]
sudo apt install valgrind
\end{lstlisting}

Generalmente, Valgrind viene eseguito nel seguente modo:

\begin{lstlisting}[language=bash]
valgrind --tool=toolname program
\end{lstlisting}
dove \texttt{toolname} è il nome dello strumento di Valgrind desiderato, e
\texttt{program} è il nome del programma desiderato da usare con Valgrind.

\subsection{Funzionalità}
\label{sec:valgrind:funzionalita}

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------

\section{Esempi di utilizzo}

\subsection{Esempio 1}
\label{sec:esempio1}

\subsection{Esempio 2}
\label{sec:esempio2}

\subsection{Esempio 3}
\label{sec:esempio3}

\subsection{Esempio 4}
\label{sec:esempio4}

%----------------------------------------------------------------------------------------
%	SECTION 5
%----------------------------------------------------------------------------------------

\section{Casi studio complessi}

\subsection{Esempio 1}
\label{sec:complesso1}

%----------------------------------------------------------------------------------------
%	SECTION 6
%----------------------------------------------------------------------------------------

\section{Conclusioni}

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\bibliography{biblio}

%----------------------------------------------------------------------------------------


\end{document}