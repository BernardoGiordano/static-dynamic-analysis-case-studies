\documentclass{article}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{polyglossia}
\setdefaultlanguage{italian}
\setotherlanguages{english}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\setlength\parindent{0pt}
\title{
    Analisi statica e dinamica di codice \texttt{C/C++} \\ con
    \texttt{Cppcheck} e \texttt{Valgrind} \\ \vspace{16px}
    \small Corso di Affidabilità e Sicurezza \\ dei Sistemi Software Complessi A.A. 2019/2020
}

\author{\textsc{Bernardo Giordano A18/254}}
\date{\today}

\begin{document}
\maketitle

\newpage

\tableofcontents

\newpage

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introduzione}

\subsection{Obiettivo}
\label{sec:obiettivo}

L'obiettivo dell'assignment è quello di approfondire le tecniche di analisi
statica e dinamica del codice \texttt{C/C++} per scoprire problemi relativi allo
scorretto utilizzo della memoria, come ad esempio mancata deallocazione (memory
leak), accesso a locazioni di memoria non valide e undefined behaviour.

In particolare, si approfondiranno i software open source \texttt{Cppcheck} e
\texttt{Valgrind} rispettivamente per l'analisi statica e quella dinamica.

\subsection{Analisi statica}
\label{sec:analisistatica}

L'analisi statica è un processo di valutazione di un sistema (in questo caso
software) o di un suo componente, volto all'analisi della sua forma, contenuto e
struttura senza che esso sia messo in esecuzione. Nella maggior parte dei casi,
l'analisi statica viene eseguita direttamente sul codice sorgente o sul codice
oggetto del programma.

L'analisi statica effettuata sul software varia a seconda del tool, in quanto
alcuni vanno a considerare solo il comportamento degli statement singoli e le
dichiarazioni di variabili all'interno di una porzione circoscritta di codice,
mentre altri vanno ad effettuare una analisi complessiva a partire dal codice
sorgente completo del programma. 

Le informazioni che si ricavano da un processo di analisi statica variano sono
molto variegate:

\begin{enumerate}
    \item highlighting di errori nel coding (sintattici o meno), come avviene
    per i tool di \emph{linting}
    \item segnalazione di variabili dichiarate e mai usate
    \item segnalazione di funzioni dichiarate e mai invocate
    \item segnalazione di memoria mai deallocata (\emph{memory leak})
    \item segnalazione di possibili loop infiniti dovuti all'irraggiungibilità
    di una o più condizioni di arresto
    \item \ldots
\end{enumerate}

L'analisi statica è una fase molto importante dello sviluppo del software (in
particolare in fase di validazione) e viene utilizzata spesso per sistemi
safety-critical e per scovare codice potenzialmente vulnerabile. Un corretto
utilizzo di questa tecnica previene l'occorrenza di errori all'interno del
software in fase di esecuzione e permette di rilasciare software in produzione
che non presenta guasti che spesso si vanno a scoprire solo con il codice in
esecuzione, quando magari è già tardi perché si sono già manifestati in fallimenti.

Tra le varie tecniche di analisi statica troviamo:

\begin{itemize}
    \item Analisi statica in compilazione: viene effettuata dal compilatore
    prima di generare il codice oggetto, per verificare caratteristiche di
    correttezza (sintattica, di coerenza tra tipi e parametri, codice non raggiungibile)
    \item Code reading: lettura individuale del codice per evidenziare
    errori/discrepanze con il progetto (tecniche basate su checklist o guidate
    dai casi d'uso)
    \item Code review: riunioni formali a cui partecipa un gruppo di persone che
    revisiona il codice allo stesso tempo
    \item Walkthrough: simulazione di casi di test eseguendo le istruzioni nel
    codice a mano
    \item Analisi del dataflow: studio del \emph{Control Flow Graph}
    \item Esecuzione simbolica: esecuzione del programma con valori simbolici
    dei dati di input invece che con valori effettivi
\end{itemize}

\subsection{Analisi dinamica}
\label{sec:analisidinamica}

L'analisi dinamica è un processo di analisi del software che prevede
l'esecuzione di un programma su un processore reale o virtuale. \\

Ci sono diverse tipologie di analisi dinamica:

\begin{itemize}
    \item Code coverage: serve a misurare il grado di utilizzo del codice
    sorgente di un programma quando viene eseguita una particolare test suite
    \item Memory error detection: serve a identificare problemi dovuti alla
    mancata deallocazione dinamica di memoria e a memory leaks.
    \item Fault localization: serve a localizzare bugs nel codice basandosi sui
    casi di test passati o falliti.
    \item Concurrency errors detection: serve a identificare condizioni di
    corsa, eccezioni e deadlock in codice multithread o concorrente.
    \item Performance analysis: il programma in esecuzione viene analizzato per
    identificare eventuali problemi prestazionali.
\end{itemize}

\subsection{Aging}
\label{sec:aging}

Con l'aging del software si fa riferimento alla tendenza dei software di
fallire, o di causare fallimenti del sistema complessivo in cui operano, quando
sono eseguiti continuamente per un certo intervallo di tempo. I fattori che
causano l'aging del software sono il memory bloating e il memory leaking, la
corruzione dei dati in memoria e il mancato rilascio di risorse richieste al
sistema operativo come gli handler dei file e delle socket. \\

Una tecnica proattiva per contrastare l'aging è la \emph{software rejuvenation},
che consiste nel rimuovere condizioni accumulate che possono portare ad errore,
anche semplicemente riavviando il software o la macchina sulla quale esso
opera. \\

Tra le cause principali dietro l'aging del software, troviamo il \emph{memory
leak}. Ogni qual volta un software in esecuzione su un sistema operativo deve
effettuare delle operazioni, esso deve richiedere blocchi di memoria per
allocare eventuali variabili e strutture dati. Quando il software termina la
propria esecuzione, il sistema operativo si aspetta che il programma abbia
liberato completamente la memoria richiesta all'avvio e durante l'esecuzione
(variabili allocate, rispettivamente, staticamente e dinamicamente). Nei
linguaggi di programmazione che prevedono un garbage collector (e.g. Java)
l'allocazione dinamica della memoria non è direttamente consentita al
programmatore e la memoria viene automaticamente liberata da un garbage
collector, che ha memoria dei riferimenti che vengono fatti ad una particolare
locazione di memoria; quando essa non viene più utilizzata dal programma, viene
liberata. In altri linguaggi come invece il C o il C++, che non hanno a
disposizione un garbage collector (in quanto, ad esempio, a differenza del Java
non operano sotto una Virtual Machine), la mancata deallocazione di memoria da
parte del programmatore può causare memory leaks. \\

È quindi importante, in fase di sviluppo, prestare la dovuta attenzione alle
allocazioni e alle deallocazioni di memoria e al suo utilizzo. Vengono incontro
a questo scopo dei tool come Cppcheck e Valgrind che sono di supporto in fase di
sviluppo per effettuare analisi statica e dinamica volta all'identificazione di
utilizzo scorretto della memoria.
 
%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Cppcheck}

\subsection{Panoramica}
\label{sec:cppcheck:panoramica}

Cppcheck è un tool per l'analisi statica di codice C e C++. Esso si concentra
sull'identificazione di undefined behaviour, utilizzo scorretto delle risorse e
costrutti potenzialmente pericolosi. Cppcheck è fatto in modo tale da avere un
numero di falsi positivi molto basso anche in condizioni di codice con sintassi
non standard e customizzata (situazione comune nei sistemi embedded).

\subsection{Installazione}
\label{sec:cppcheck:installazione}

Cppcheck può essere installato in semplicemente da un repository
che lo contiene, oppure direttamente da pacchetto. Ad esempio, su
una distribuzione Debian/Ubuntu: \\

\begin{lstlisting}[language=bash]
sudo apt install cppcheck
\end{lstlisting}

\subsection{Funzionalità}
\label{sec:cppcheck:funzionalita}

Cppcheck possiede una interfaccia grafica e una a riga di comando, a seconda
delle esigenze dell'utilizzatore. Per questo assignment, ci si concentrerà
sull'utilizzo tramite \emph{command line interface}. \\

Cppcheck è progettato affinché la data flow analysis sia \emph{bidirezionale} e non
solo \emph{forward}, come avviene per altri tool analoghi. Questo significa che
Cppcheck è in grado di diagnosticare problemi che altri tool non evidenziano.
Molti tool di analisi statica evidenzieranno questo problema di overflow della memoria:

\begin{lstlisting}[language=c]
void foo(int x) {
    int buf[10];
    if (x == 1000)
        buf[x] = 0; // <- ERRORE
}
\end{lstlisting}

Altri tool invece è in grado di diagnosticare anche problemi di overflow come il
seguente, che comportano undefined behaviour:

\begin{lstlisting}[language=c]
void foo(int x) {
    int buf[10];
    buf[x] = 0; // <- UNDEFINED BEHAVIOUR SE x >= 10
    if (x == 1000) {}
}
\end{lstlisting}

Altri esempi di undefined behaviour che Cppcheck riesce ad identificare sono i
seguenti:

\begin{itemize}
    \item Dead pointers
    \item Divisione per zero
    \item Integer overflows
    \item Operandi di bit shift invalidi
    \item Conversioni invalide
    \item Utilizzo scorretto della Standard Library
    \item Gestione della memoria
    \item Null pointer dereferences
    \item Controllo degli indici \emph{out of bounds}
    \item Uso di variabili non inizializzate
    \item Scrittura su costanti
\end{itemize}

%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------

\section{Valgrind}

\subsection{Panoramica}
\label{sec:valgrind:panoramica}

Valgrind è un framework in grado di fornire una strumentazione ai binari dello spazio utente. \\

Valgrind rende disponibili un certo numero di strumenti per il profiling per il
miglioramento delle prestazioni e per una esecuzione corretta
delle applicazioni. Questi strumenti sono in grado di rilevare errori relativi
ai thread e alla memoria, permettendo
così una identificazione e correzione più semplice degli errori nel codice
dell'applicazione. Essi sono in grado di analizzare la cache, l'heap e la
previsione del branch, per identificare i fattori in grado di aumentare la
velocità dell'applicazione e ridurre l'uso della memoria. \\

Valgrind analizza l'applicazione eseguendola su una CPU sintetica, monitorandola
e misurando le prestazioni del codice esistente durante la sua esecuzione.
Successivamente stampa dei report identificando ogni processo presente
nell'esecuzione dell'applicazione su un descrittore del file specificato
dall'utente, un file, o una socket di rete. Il livello di arricchimento delle
funzioni eseguite varia in base
allo strumento di Valgrind usato e alle impostazioni, ed è importante notare
che l'esecuzione di un codice "instrumentato" può richiedere un tempo dai 4-50
volte più lungo rispetto al tempo di esecuzione normale. \\

Valgrind può essere usato sulle applicazioni senza alcuna ricompilazione
aggiuntiva. Tuttavia, poichè Valgrind utilizza informazioni di debugging per
definire le problematiche nel codice, se l'applicazione e le librerie di
supporto non sono state compilate con informazioni di debugging abilitate, è
generalmente consigliato ricompilare l'applicazione in modalità di debug.

\subsection{Installazione}
\label{sec:valgrind:installazione}

Il framework Valgrind può essere installato in semplicemente da un repository
che lo contiene, oppure direttamente da pacchetto. Ad esempio, su
una distribuzione Debian/Ubuntu: \\

\begin{lstlisting}[language=bash]
sudo apt install valgrind
\end{lstlisting}

Generalmente, Valgrind viene eseguito nel seguente modo:

\begin{lstlisting}[language=bash]
valgrind --tool=toolname program
\end{lstlisting}
dove \texttt{toolname} è il nome dello strumento di Valgrind desiderato, e
\texttt{program} è il nome del programma desiderato da usare con Valgrind.

\subsection{Funzionalità}
\label{sec:valgrind:funzionalita}

La suite Valgrind contiene al suo interno un vasto assortimento di strumenti di
debugging e profiling.

\subsubsection{Memcheck}

Memcheck rileva i problemi di gestione della memoria ed è
rivolto principalmente ai programmi C e C++. Quando un programma viene eseguito
sotto la supervisione di Memcheck, tutte le letture e le scritture della memoria
vengono controllate e le chiamate a \texttt{malloc}, \texttt{new}, \texttt{free}
e \texttt{delete} vengono intercettate. Di conseguenza, Memcheck può rilevare se
il programma:

\begin{itemize}
    \item Accede a memoria che non dovrebbe (aree non ancora allocate, aree che
    sono state liberate, aree oltre la fine dei blocchi di heap, aree inaccessibili dello stack).
    \item Utilizza valori non inizializzati.
    \item Perde memoria.
    \item Esegue liberazioni errate di blocchi di heap (double free).
    \item Passa blocchi di memoria di origine e destinazione sovrapposti a \texttt{memcpy}
    e alle funzioni correlate.
\end{itemize}

Memcheck segnala questi errori non appena si verificano, fornendo il numero di
riga di origine in cui si è verificato e anche una traccia dello stack delle
funzioni chiamate per raggiungere quella riga. Memcheck tiene traccia
dell'indirizzabilità a livello di byte e dell'inizializzazione dei valori a
livello di bit. Di conseguenza, è in grado di rilevare l'uso di singoli bit non
inizializzati.
Memcheck esegue programmi circa 10-30 volte più lentamente del normale.

\subsubsection{Cachegrind}

Cachegrind è un profiler della cache. Esegue una simulazione dettagliata delle
cache L1 ed L2 nella CPU e quindi può individuare con precisione le fonti di
\emph{cache miss} nel codice. Identifica il numero di cache miss, riferimenti di
memoria e istruzioni eseguite per ogni riga di codice sorgente, con riepiloghi
per funzione, per modulo e per l'intero programma. È utilizzabile con programmi scritti
in qualsiasi linguaggio. Cachegrind esegue i programmi circa 20-100 volte più
lentamente del normale. \\

Callgrind è un tool aggiuntivo che nasce come estensione di Cachegrind, che
fornisce informazioni aggiuntive sui call graphs.

\subsubsection{Massif}

Massif è un profiler della memoria heap. Esegue una profilazione dettagliata dell'heap
acquisendo istantanee regolari dell'heap di un programma. Produce un grafico che
mostra l'utilizzo dell'heap nel tempo, comprese le informazioni su quali parti
del programma sono responsabili della maggior parte delle allocazioni di
memoria. Il grafico è integrato da un file di testo o HTML che include ulteriori
informazioni per determinare dove viene allocata la maggior parte della memoria.
Massif esegue programmi circa 20 volte più lentamente del normale.

\subsubsection{Helgrind}

Helgrind è un debugger di thread che trova race conditions in programmi
multithread. Cerca le posizioni di memoria a cui si accede da più di un thread
(POSIX o pthread), ma per le quali non è possibile trovare alcun blocco
utilizzato in modo coerente. Tali posizioni sono indicative
della mancata sincronizzazione tra i thread e potrebbero causare problemi
dipendenti dalla temporizzazione altrimenti difficili da trovare. È utile per qualsiasi
programma che utilizza i pthreads.

\subsubsection{DRD}

DRD è uno strumento per rilevare errori nei programmi C e C++ multithread. Lo
strumento funziona per qualsiasi programma che utilizza le primitive di
threading POSIX o che utilizza concetti di threading costruiti sopra le
primitive di threading POSIX. Sebbene Helgrind possa rilevare le violazioni
dell'ordine di blocco, per la maggior parte dei programmi DRD necessita di meno
memoria per eseguire la sua analisi, e quindi può essere considerato come
un'alternativa.

\subsubsection{DHAT}

DHAT è uno strumento per esaminare come i programmi utilizzano le allocazioni di
heap. Tiene traccia dei blocchi allocati e ispeziona ogni accesso alla memoria
per trovare quale blocco deve essere allocato. Viene fornito con una GUI per
facilitare l'esplorazione dei risultati di profiling.

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------

\section{Esempi di utilizzo}

\subsection{Esempio 1}
\label{sec:esempio1}

\subsection{Esempio 2}
\label{sec:esempio2}

\subsection{Esempio 3}
\label{sec:esempio3}

\subsection{Esempio 4}
\label{sec:esempio4}

%----------------------------------------------------------------------------------------
%	SECTION 5
%----------------------------------------------------------------------------------------

\section{Casi studio complessi}

\subsection{Esempio 1}
\label{sec:complesso1}

%----------------------------------------------------------------------------------------
%	SECTION 6
%----------------------------------------------------------------------------------------

\section{Conclusioni}

\end{document}