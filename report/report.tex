\documentclass{article}

\usepackage{graphicx}
\usepackage{listings}
\usepackage{polyglossia}
\setdefaultlanguage{italian}
\setotherlanguages{english}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\setlength\parindent{0pt}
\title{
    Analisi statica e dinamica di codice \texttt{C/C++} \\ con
    \texttt{Cppcheck} e \texttt{Valgrind} \\ \vspace{16px}
    \small Corso di Affidabilità e Sicurezza \\ dei Sistemi Software Complessi A.A. 2019/2020
}

\author{\textsc{Bernardo Giordano A18/254}}
\date{\today}

\begin{document}
\maketitle

\newpage

\tableofcontents

\newpage

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introduzione}

\subsection{Obiettivo}
\label{sec:obiettivo}

L'obiettivo dell'assignment è quello di approfondire le tecniche di analisi
statica e dinamica del codice \texttt{C/C++} per scoprire problemi relativi allo
scorretto utilizzo della memoria, come ad esempio mancata deallocazione (memory
leak), accesso a locazioni di memoria non valide e undefined behaviour.

In particolare, si approfondiranno i software open source \texttt{Cppcheck} e
\texttt{Valgrind} rispettivamente per l'analisi statica e quella dinamica.

\subsection{Analisi statica}
\label{sec:analisistatica}

L'analisi statica è un processo di valutazione di un sistema (in questo caso
software) o di un suo componente, volto all'analisi della sua forma, contenuto e
struttura senza che esso sia messo in esecuzione. Nella maggior parte dei casi,
l'analisi statica viene eseguita direttamente sul codice sorgente o sul codice
oggetto del programma.

L'analisi statica effettuata sul software varia a seconda del tool, in quanto
alcuni vanno a considerare solo il comportamento degli statement singoli e le
dichiarazioni di variabili all'interno di una porzione circoscritta di codice,
mentre altri vanno ad effettuare una analisi complessiva a partire dal codice
sorgente completo del programma. 

Le informazioni che si ricavano da un processo di analisi statica variano sono
molto variegate:

\begin{enumerate}
    \item highlighting di errori nel coding (sintattici o meno), come avviene
    per i tool di \emph{linting}
    \item segnalazione di variabili dichiarate e mai usate
    \item segnalazione di funzioni dichiarate e mai invocate
    \item segnalazione di memoria mai deallocata (\emph{memory leak})
    \item segnalazione di possibili loop infiniti dovuti all'irraggiungibilità
    di una o più condizioni di arresto
    \item \ldots
\end{enumerate}

L'analisi statica è una fase molto importante dello sviluppo del software (in
particolare in fase di validazione) e viene utilizzata spesso per sistemi
safety-critical e per scovare codice potenzialmente vulnerabile. Un corretto
utilizzo di questa tecnica previene l'occorrenza di errori all'interno del
software in fase di esecuzione e permette di rilasciare software in produzione
che non presenta guasti che spesso si vanno a scoprire solo con il codice in
esecuzione, quando magari è già tardi perché si sono già manifestati in fallimenti.

Tra le varie tecniche di analisi statica troviamo:

\begin{itemize}
    \item Analisi statica in compilazione: viene effettuata dal compilatore
    prima di generare il codice oggetto, per verificare caratteristiche di
    correttezza (sintattica, di coerenza tra tipi e parametri, codice non raggiungibile)
    \item Code reading: lettura individuale del codice per evidenziare
    errori/discrepanze con il progetto (tecniche basate su checklist o guidate
    dai casi d'uso)
    \item Code review: riunioni formali a cui partecipa un gruppo di persone che
    revisiona il codice allo stesso tempo
    \item Walkthrough: simulazione di casi di test eseguendo le istruzioni nel
    codice a mano
    \item Analisi del dataflow: studio del \emph{Control Flow Graph}
    \item Esecuzione simbolica: esecuzione del programma con valori simbolici
    dei dati di input invece che con valori effettivi
\end{itemize}

\subsection{Analisi dinamica}
\label{sec:analisidinamica}

L'analisi dinamica è un processo di analisi del software che prevede
l'esecuzione di un programma su un processore reale o virtuale. \\

Ci sono diverse tipologie di analisi dinamica:

\begin{itemize}
    \item Code coverage: serve a misurare il grado di utilizzo del codice
    sorgente di un programma quando viene eseguita una particolare test suite
    \item Memory error detection: serve a identificare problemi dovuti alla
    mancata deallocazione dinamica di memoria e a memory leaks.
    \item Fault localization: serve a localizzare bugs nel codice basandosi sui
    casi di test passati o falliti.
    \item Concurrency errors detection: serve a identificare condizioni di
    corsa, eccezioni e deadlock in codice multithread o concorrente.
    \item Performance analysis: il programma in esecuzione viene analizzato per
    identificare eventuali problemi prestazionali.
\end{itemize}

\subsection{Aging}
\label{sec:aging}

Con l'aging del software si fa riferimento alla tendenza dei software di
fallire, o di causare fallimenti del sistema complessivo in cui operano, quando
sono eseguiti continuamente per un certo intervallo di tempo. I fattori che
causano l'aging del software sono il memory bloating e il memory leaking, la
corruzione dei dati in memoria e il mancato rilascio di risorse richieste al
sistema operativo come gli handler dei file e delle socket. \\

Una tecnica proattiva per contrastare l'aging è la \emph{software rejuvenation},
che consiste nel rimuovere condizioni accumulate che possono portare ad errore,
anche semplicemente riavviando il software o la macchina sulla quale esso
opera. \\

Tra le cause principali dietro l'aging del software, troviamo il \emph{memory
leak}. Ogni qual volta un software in esecuzione su un sistema operativo deve
effettuare delle operazioni, esso deve richiedere blocchi di memoria per
allocare eventuali variabili e strutture dati. Quando il software termina la
propria esecuzione, il sistema operativo si aspetta che il programma abbia
liberato completamente la memoria richiesta all'avvio e durante l'esecuzione
(variabili allocate, rispettivamente, staticamente e dinamicamente). Nei
linguaggi di programmazione che prevedono un garbage collector (e.g. Java)
l'allocazione dinamica della memoria non è direttamente consentita al
programmatore e la memoria viene automaticamente liberata da un garbage
collector, che ha memoria dei riferimenti che vengono fatti ad una particolare
locazione di memoria; quando essa non viene più utilizzata dal programma, viene
liberata. In altri linguaggi come invece il C o il C++, che non hanno a
disposizione un garbage collector (in quanto, ad esempio, a differenza del Java
non operano sotto una Virtual Machine), la mancata deallocazione di memoria da
parte del programmatore può causare memory leaks. \\

È quindi importante, in fase di sviluppo, prestare la dovuta attenzione alle
allocazioni e alle deallocazioni di memoria e al suo utilizzo. Vengono incontro
a questo scopo dei tool come Cppcheck e Valgrind che sono di supporto in fase di
sviluppo per effettuare analisi statica e dinamica volta all'identificazione di
utilizzo scorretto della memoria.
 
%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Cppcheck}

\subsection{Panoramica}
\label{sec:cppcheck:panoramica}

Cppcheck è un tool per l'analisi statica di codice C e C++. Esso si concentra
sull'identificazione di undefined behaviour, utilizzo scorretto delle risorse e
costrutti potenzialmente pericolosi. Cppcheck è fatto in modo tale da avere un
numero di falsi positivi molto basso anche in condizioni di codice con sintassi
non standard e customizzata (situazione comune nei sistemi embedded).

\subsection{Installazione}
\label{sec:cppcheck:installazione}

Cppcheck può essere installato in semplicemente da un repository
che lo contiene, oppure direttamente da pacchetto. Ad esempio, su
una distribuzione Debian/Ubuntu: \\

\begin{lstlisting}[language=bash]
sudo apt install cppcheck
\end{lstlisting}

\subsection{Funzionalità}
\label{sec:cppcheck:funzionalita}

Cppcheck possiede una interfaccia grafica e una a riga di comando, a seconda
delle esigenze dell'utilizzatore. Per questo assignment, ci si concentrerà
sull'utilizzo tramite \emph{command line interface}. \\

Cppcheck è progettato affinché la data flow analysis sia \emph{bidirezionale} e non
solo \emph{forward}, come avviene per altri tool analoghi. Questo significa che
Cppcheck è in grado di diagnosticare problemi che altri tool non evidenziano.
Molti tool di analisi statica evidenzieranno questo problema di overflow della memoria:

\begin{lstlisting}[language=c]
void foo(int x) {
    int buf[10];
    if (x == 1000)
        buf[x] = 0; // <- ERRORE
}
\end{lstlisting}

Altri tool invece è in grado di diagnosticare anche problemi di overflow come il
seguente, che comportano undefined behaviour:

\begin{lstlisting}[language=c]
void foo(int x) {
    int buf[10];
    buf[x] = 0; // <- UNDEFINED BEHAVIOUR SE x >= 10
    if (x == 1000) {}
}
\end{lstlisting}

Altri esempi di undefined behaviour che Cppcheck riesce ad identificare sono i
seguenti:

\begin{itemize}
    \item Dead pointers
    \item Divisione per zero
    \item Integer overflows
    \item Operandi di bit shift invalidi
    \item Conversioni invalide
    \item Utilizzo scorretto della Standard Library
    \item Gestione della memoria
    \item Null pointer dereferences
    \item Controllo degli indici \emph{out of bounds}
    \item Uso di variabili non inizializzate
    \item Scrittura su costanti
\end{itemize}

%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------

\section{Valgrind}

\subsection{Panoramica}
\label{sec:valgrind:panoramica}

Valgrind è un framework in grado di fornire una strumentazione ai binari dello spazio utente. \\

Valgrind rende disponibili un certo numero di strumenti per il profiling per il
miglioramento delle prestazioni e per una esecuzione corretta
delle applicazioni. Questi strumenti sono in grado di rilevare errori relativi
ai thread e alla memoria, permettendo
così una identificazione e correzione più semplice degli errori nel codice
dell'applicazione. Essi sono in grado di analizzare la cache, l'heap e la
previsione del branch, per identificare i fattori in grado di aumentare la
velocità dell'applicazione e ridurre l'uso della memoria. \\

Valgrind analizza l'applicazione eseguendola su una CPU sintetica, monitorandola
e misurando le prestazioni del codice esistente durante la sua esecuzione.
Successivamente stampa dei report identificando ogni processo presente
nell'esecuzione dell'applicazione su un descrittore del file specificato
dall'utente, un file, o una socket di rete. Il livello di arricchimento delle
funzioni eseguite varia in base
allo strumento di Valgrind usato e alle impostazioni, ed è importante notare
che l'esecuzione di un codice "instrumentato" può richiedere un tempo dai 4-50
volte più lungo rispetto al tempo di esecuzione normale. \\

Valgrind può essere usato sulle applicazioni senza alcuna ricompilazione
aggiuntiva. Tuttavia, poichè Valgrind utilizza informazioni di debugging per
definire le problematiche nel codice, se l'applicazione e le librerie di
supporto non sono state compilate con informazioni di debugging abilitate, è
generalmente consigliato ricompilare l'applicazione in modalità di debug.

\subsection{Installazione}
\label{sec:valgrind:installazione}

Il framework Valgrind può essere installato in semplicemente da un repository
che lo contiene, oppure direttamente da pacchetto. Ad esempio, su
una distribuzione Debian/Ubuntu: \\

\begin{lstlisting}[language=bash]
sudo apt install valgrind
\end{lstlisting}

Generalmente, Valgrind viene eseguito nel seguente modo:

\begin{lstlisting}[language=bash]
valgrind --tool=toolname program
\end{lstlisting}
dove \texttt{toolname} è il nome dello strumento di Valgrind desiderato, e
\texttt{program} è il nome del programma desiderato da usare con Valgrind.

\subsection{Funzionalità}
\label{sec:valgrind:funzionalita}

La suite Valgrind contiene al suo interno un vasto assortimento di strumenti di
debugging e profiling.

\subsubsection{Memcheck}

Memcheck rileva i problemi di gestione della memoria ed è
rivolto principalmente ai programmi C e C++. Quando un programma viene eseguito
sotto la supervisione di Memcheck, tutte le letture e le scritture della memoria
vengono controllate e le chiamate a \texttt{malloc}, \texttt{new}, \texttt{free}
e \texttt{delete} vengono intercettate. Di conseguenza, Memcheck può rilevare se
il programma:

\begin{itemize}
    \item Accede a memoria che non dovrebbe (aree non ancora allocate, aree che
    sono state liberate, aree oltre la fine dei blocchi di heap, aree inaccessibili dello stack).
    \item Utilizza valori non inizializzati.
    \item Perde memoria.
    \item Esegue liberazioni errate di blocchi di heap (double free).
    \item Passa blocchi di memoria di origine e destinazione sovrapposti a \texttt{memcpy}
    e alle funzioni correlate.
\end{itemize}

Memcheck segnala questi errori non appena si verificano, fornendo il numero di
riga di origine in cui si è verificato e anche una traccia dello stack delle
funzioni chiamate per raggiungere quella riga. Memcheck tiene traccia
dell'indirizzabilità a livello di byte e dell'inizializzazione dei valori a
livello di bit. Di conseguenza, è in grado di rilevare l'uso di singoli bit non
inizializzati.
Memcheck esegue programmi circa 10-30 volte più lentamente del normale. \\

Gli errori precedentemente menzionati vengono solo segnalati da Memcheck, che
non impedisce la loro generazione. Se un programma esegue un accesso alla
memoria che genera un errore di segmentazione, questo errore si verificherà anche se
si utilizza Memcheck. Detto questo, Memcheck registrerà un messaggio
immediatamente prima dell'errore. \\

Memcheck fornisce diverse opzioni a riga di comando per rendere l'analisi più flessibile. Alcune di queste opzioni sono:

\begin{description}
    \item[\texttt{--leak-check}] Se abilitato Memcheck va alla ricerca di perdite di memoria
    quando il programma termina la sua esecuzione. Il valore predefinito è
    \texttt{summary}, e il suo output riporta il numero di perdite trovate. Altri valori
    possibili sono \texttt{yes} e \texttt{full}, entrambi riportano le informazioni su ogni perdita
    individuale e \texttt{no} disabilita questo tipo di controllo.

    \item[\texttt{--undef-value-errors}] Se abilitato (impostato su \texttt{yes}), Memcheck riporta gli errori se vengono
    usati valori non identificati. Se disabilitato (impostato su \texttt{no}), questi
    errori non vengono riportati. Questa opzione è abilitata per impostazione
    predefinita. La sua disabilitazione aumenta leggermente la velocità di
    esecuzione di Memcheck.
\end{description}

\subsubsection{Cachegrind}

Cachegrind è un profiler della cache. Esegue una simulazione dettagliata delle
cache L2 nella CPU e quindi può individuare con precisione le fonti di
\emph{cache miss} nel codice. Identifica il numero di cache miss, riferimenti di
memoria e istruzioni eseguite per ogni riga di codice sorgente, con riepiloghi
per funzione, per modulo e per l'intero programma. È utilizzabile con programmi scritti
in qualsiasi linguaggio. Cachegrind esegue i programmi circa 20-100 volte più
lentamente del normale. \\

Cachegrind è in grado di ottenere le seguenti informazioni per l'intero programma e per ogni funzione presente al suo interno:

\begin{itemize}
    \item Richieste di lettura non eseguite (read misses) e lettura (o
    istruzioni eseguite) delle istruzioni per cache del primo livello, e
    richieste di lettura non eseguite per le istruzioni della cache dell'ultimo livello.
    \item Lettura dati della cache (o lettura della memoria), richieste di lettura non eseguite.
    \item Scrittura dati della cache (o scrittura della memoria), richieste di scrittura non eseguite.
    \item Branch condizionali eseguiti e previsti incorrettamente.
    \item Branch indiretti eseguiti e previsti incorrettamente.
\end{itemize}

Per impostazione predefinita Cachegrind stampa un sommario delle informazioni
relative alle statistiche sopra riportate, e scrive in modo più dettagliato le
informazioni sul profiling su un file (\texttt{cachegrind.out.pid}, dove \texttt{pid} è l'ID del
processo del programma sul quale è stato eseguito Cachegrind). \\

Alcune opzioni da riga di comando per rendere l'analisi più flessibile sono le
seguenti:

\begin{description}
    \item[\texttt{--cache-sim}] Abilita o disabilita la raccolta dei conteggi relativi al mancato accesso e dell'accesso della cache. Il valore predefinito è \texttt{yes} (abilitato).
    \item[\texttt{--branch-sim}] Abilita o disabilita la raccolta delle informazioni relative ai conteggi
    previsti incorrettamente e sulle istruzioni del branch. Per impostazione
    predefinita questa opzione è impostata su \texttt{no} (disabilitato), poichè
    rallenterà Cachegrind di circa il 25 per cento. 
\end{description}

Callgrind è un tool aggiuntivo che nasce come estensione di Cachegrind, che
fornisce informazioni aggiuntive sui call graphs.

\subsubsection{Massif}

Massif è un profiler della memoria heap. Esegue una profilazione dettagliata dell'heap
acquisendo istantanee regolari dell'heap di un programma. Produce un grafico che
mostra l'utilizzo dell'heap nel tempo, comprese le informazioni su quali parti
del programma sono responsabili della maggior parte delle allocazioni di
memoria. Il grafico è integrato da un file di testo o HTML che include ulteriori
informazioni per determinare dove viene allocata la maggior parte della memoria.
Massif esegue programmi circa 20 volte più lentamente del normale. \\

I dati sul profiling raccolti da Massif vengono scritti su un file che per
impostazione predefinita viene chiamato \texttt{massif.out.pid}, dove \texttt{pid} è l'ID del processo del programma specificato.
Questi dati possono essere rappresentati in modo grafico con il comando \texttt{ms\_print}.

\begin{lstlisting}[language=bash]
ms_print massif.out.pid
\end{lstlisting}

Così facendo verrà generato un grafico sul consumo della memoria relativa
all'esecuzione del programma. \\

Massif fornisce un certo numero di opzioni della linea di comando utilizzabili.
Alcune opzioni disponibili sono: 

\begin{description}
    \item[\texttt{--heap}] Specifica se eseguire il profiling di heap. Il valore predefinito è \texttt{yes}. Il profiling di heap può essere disabilitato impostando questa opzione su \texttt{no}. 
    \item[\texttt{--heap-admin}] Specifica il numero di byte per blocco da usare per la gestione quando il profiling di heap è abilitato. Il valore predefinito è 8 byte per blocco.
    \item[\texttt{--stacks}] Specifica se eseguire il profiling dello stack. Il
    valore predefinito è \texttt{no} (disabilitato). Per abilitare il profiling
    dello stack bisogna impostare questa opzione su yes, ma in questo modo verrà sensibilmente rallentata l'esecuzione di Massif. Da
    notare che Massif assume che la dimensione dello stack sia zero
    all'avvio.
    \item[\texttt{--time-unit}] Specifica l'unità di tempo usata per il profiling. Sono disponibili tre
    valori validi per questa opzione: istruzioni eseguite (\texttt{i}), il valore
    predefinito, che risulta utile in numerosi casi; real time (\texttt{ms}, in
    millisecondi), utile in determinate situazioni; e byte allocati/deallocati
    sull'heap/o stack (\texttt{B}), utile per programmi eseguiti brevemente e per
    l'esecuzione di test, poichè questo processo risulta essere quello più
    facilmente riproducibile su diverse macchine. Questa opzione è utile per un
    grafico dell'output di Massif con \texttt{ms\_print}. 
\end{description}


\subsubsection{Helgrind}

Helgrind è un debugger di thread che trova race conditions in programmi
multithread. Cerca le posizioni di memoria a cui si accede da più di un thread
(POSIX o pthread), ma per le quali non è possibile trovare alcun blocco
utilizzato in modo coerente. Tali posizioni sono indicative
della mancata sincronizzazione tra i thread e potrebbero causare problemi
dipendenti dalla temporizzazione altrimenti difficili da trovare. È utile per qualsiasi
programma che utilizza i pthreads.

\subsubsection{DRD}

DRD è uno strumento per rilevare errori nei programmi C e C++ multithread. Lo
strumento funziona per qualsiasi programma che utilizza le primitive di
threading POSIX o che utilizza concetti di threading costruiti sopra le
primitive di threading POSIX. Sebbene Helgrind possa rilevare le violazioni
dell'ordine di blocco, per la maggior parte dei programmi DRD necessita di meno
memoria per eseguire la sua analisi, e quindi può essere considerato come
un'alternativa.

\subsubsection{DHAT}

DHAT è uno strumento per esaminare come i programmi utilizzano le allocazioni di
heap. Tiene traccia dei blocchi allocati e ispeziona ogni accesso alla memoria
per trovare quale blocco deve essere allocato. Viene fornito con una GUI per
facilitare l'esplorazione dei risultati di profiling.

%----------------------------------------------------------------------------------------
%	SECTION 4
%----------------------------------------------------------------------------------------

\newpage
\section{Esempi di utilizzo}

\subsection{Caso 1}
\label{sec:caso1}

\newpage
\subsection{Caso 2}
\label{sec:caso2}

\newpage
\subsection{Caso 3}
\label{sec:caso3}

\newpage
\subsection{Caso 4}
\label{sec:caso4}

\begin{lstlisting}[language=c]
#include <stdio.h>

int main(int argc, char** argv) {
    char buffer[10];
    if (argc == 2) {
        sprintf(buffer, "%s", argv[1]);
    }
    printf("%s\n", buffer);
    return 0;
}
\end{lstlisting}

Il seguente codice può presentare undefined behaviour se al programma non
vengono passati parametri (o ne viene passato più di uno), in quanto viene
stampato un buffer di caratteri non inizializzato in output. Inoltre, il
programma presenta codice non sicuro in quanto viene utilizzata la funzione
\texttt{sprintf} invece che la sua variante più safe \texttt{snprintf}, che
permette di specificare quanti byte scrivere nel buffer destinazione. In questo
caso, se come parametro al programma viene passato un argomento più lungo di 10
caratteri, si verificherà uno stack smashing in esecuzione. \\

Compilo il codice con \texttt{gcc main.c}. \\

Lo eseguo passando come parametro una stringa più lunga di 10 caratteri:

\begin{lstlisting}[language=bash]
$ ./a.out testtesttest
testtesttest
*** stack smashing detected ***: terminated
Annullato (core dump creato)
\end{lstlisting}

Cppcheck non è in grado di rilevare l'errore, se viene invocato \texttt{cppcheck
main.c}. \\

Valgrind restituisce un output più dettagliato e rileva gli errori previsti da
questo caso di studio.

\begin{lstlisting}[language=bash]
$ valgrind --track-origins=yes -s ./a.out 
==14564== Memcheck, a memory error detector
...
==14564== ERROR SUMMARY: 1 errors from 1 contexts 
==14564== 
==14564== 1 errors in context 1 of 1:
==14564== Conditional jump or move depends on uninitialised value(s)
==14564==    at 0x483EF49: strlen
==14564==    by 0x48F05B3: puts
==14564==    by 0x1091DF: main
==14564==  Uninitialised value was created by a stack allocation
==14564==    at 0x109189: main
==14564== 
==14564== ERROR SUMMARY: 1 errors from 1 contexts 
\end{lstlisting}

\begin{lstlisting}[language=bash]
$ valgrind --track-origins=yes -s ./a.out testtesttest
==14672== Memcheck, a memory error detector
...
==14672== Command: ./a.out testtesttest
==14672== 
testtesttest
*** stack smashing detected ***: terminated
==14672== 
==14672== Process terminating with default action of signal 6 (SIGABRT)
==14672==    at 0x48AF18B: raise (raise.c:51)
==14672==    by 0x488E858: abort (abort.c:79)
==14672==    by 0x48F93ED: __libc_message (libc_fatal.c:155)
==14672==    by 0x499BB49: __fortify_fail (fortify_fail.c:26)
==14672==    by 0x499BB15: __stack_chk_fail (stack_chk_fail.c:24)
==14672==    by 0x1091F8: main
==14672== 
==14672== HEAP SUMMARY:
==14672==     in use at exit: 0 bytes in 0 blocks
==14672==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==14672== 
==14672== All heap blocks were freed -- no leaks are possible
==14672== 
==14672== ERROR SUMMARY: 0 errors from 0 contexts 
Annullato (core dump creato)
\end{lstlisting}

In caso di stack smashing, l'esecuzione del programma viene interrotta ma
Valgrind gestine in maniera robusta il fallimento e termina correttamente
mostrando lo stacktrace che ha portato alla generazione del fallimento.

%----------------------------------------------------------------------------------------
%	SECTION 5
%----------------------------------------------------------------------------------------

\newpage
\section{Casi studio complessi}

\subsection{Esempio 1}
\label{sec:complesso1}

%----------------------------------------------------------------------------------------
%	SECTION 6
%----------------------------------------------------------------------------------------

\section{Conclusioni}

\end{document}